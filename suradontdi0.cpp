/* Copyright (c) University of British Columbia, 1999.*/
/* All rights reserved.                       */

/* SURADONDTD):  $Date: June 1999 - Last version October 2000  */
#include "su.h"
#include "segy.h"
#include "clibrarytd.h"
#include <time.h>
#include "radontd_sparse.h"

/*********************** self documentation **********************/
char *sdoc[] = {
  " 	   								",
  " SURADONTDI0 Inverse  Hyperbolic Radon transform for irregular space ", 
  " 	   								",
  " suradontdi0 datafile= modelfile vgrid= offsetfile= > stdout         ",
  "   [optional parameters]          	                         	",
  " 									",
  " 									",
  " Optional parameters:		[None]     			",
  "                                                                     ",
  " Required parameters:		[None]		       		",
  "                                                                	",
  " Output : Iterpolated traces  (offset time domain)                   ",
  " Input : sudata file  (offset time domain)              		",
  "	    sumodel file (Radon domain)                 		",
  "	    binary velocity file (saved from suradontd0)       		",
  "	    ascii offsetfile, for example obtained by                   ",
  "         sugethw key=offset output=geom                              ",
  " The purpose of this file is to compute the data from a Radon        ",
  " model computed with suradontd0 using an irregular velocity space	",
  " Rather than computing again the irregular space which require se-	",
  " veral input parameters, a file with the velocity grid is read.	",
  " This file should have been generated by suradontd0 and the default	",
  " name is vgrid. This way the program is very simple but it has to be	",
  " called inmediatelly after suradontd0. The only reason to create 	",
  " this separate file is that different processes can be performed 	",
  " in the Radon space before recovering the data.			",
  " If the offset is the same than the original data then all headers   ",
  " are preserved. Otherwise only the keywords of the first trace       ",
  " are used for all output traces, with the only update of tr.offset	",
  " tr.ntr and tr.tracl							",
  " 									",
  NULL};

/* Credits:
 *	Daniel Trad.
 * Trace header fields accessed: ns, dt, offset
 */
/**************** end self doc ***********************************/
//inv_par inv;

segy tr; 

int verbose;

int main(int argc, char **argv)
{
  cwp_String modelfile=""; /* sufile for the model */ 	
  cwp_String datafile=""; /*  sufile for the data */ 	
  cwp_String vgridfile=""; /* binary file for velocities */ 	
  cwp_String offsetfile=""; /* binary file for velocities */ 	

  FILE *mp; 
  FILE *dp;  // modelfile
  FILE *vp;
  FILE *hp;

  time_t start,finish;
  double elapsed_time;
  int it,iq,ih;
  float **data=0;
  float **model=0;
  float **vgrid=0;
  float **Wd=0;
  float *q=0;
  float *t=0;
  float *h=0;
  int smooth;
  int nt, nh, nq; 
  float dt;
  int nn;
  // smoothing
  int nl=2;  //  npoints left hand side
  int nr=2;  //  npoints left hand side
  int flag=2;  // 1 rectangular, 2 triangular
  // wavelet
  int nw;
  int iw;
  float fpeak;
  float *wavelet;
  float *dtemp;
  int typewav;  // type of wavelet
  ////////////////////////


  fprintf(stderr,"*******SURADONTD0*********\n");
  // Initialize 
  initargs(argc, argv);
  requestdoc(1);

  start=time(0);    
  // Get parameters 
  if (!getparstring("modelfile",&modelfile)) modelfile="model.su";    
  if (!getparstring("datafile",&datafile)) datafile="data.su";    
  if (!getparstring("vgridfile",&vgridfile)) vgridfile="vgrid";    
  if (!getparstring("offsetfile",&offsetfile)) offsetfile="offsetfile";    
  if (!getparint("verbose", &verbose))  verbose =0;
  if (!getparint("smooth",&smooth)) smooth=0;
  if (!getparint("nw",&nw)) nw =0;
  if (!getparint("typewav",&typewav)) typewav = 1;
  if (!getparfloat("fpeak",&fpeak)) fpeak =25;
  
  mp=efopen(modelfile,"r");
  dp=efopen(datafile,"r");
  vp=efopen(vgridfile,"r");
  hp=efopen(offsetfile,"r");
  
  // Get info from first trace 
  if (!fgettr(mp,&tr)) err("modelfile: can't read first trace");
  if (!tr.ntr) err("modelfile: ntr header field must be set");
  if (!tr.dt) err("dt header field must be set");
  if (!tr.ns) err("ns header field must be set");

  dt   = ((float) tr.dt)/1000000.0;
  nt = (int) tr.ns;
  nq= (int) tr.ntr;

  h=ealloc1float(500);

  ih=0;
  do{
    nn=fscanf(hp,"%f",&h[ih]);
    ih++;
  }while(nn==1);
  nh=ih-1;
  h=erealloc1float(h,nh);
  //  for (ih=0;ih<nh;ih++) fprintf(stderr,"h[%d]=%f\n",ih,h[ih]);

  fprintf(stderr,"nt=%d,nh=%d,nq=%d\n",nt,nh,nq);

  data=ealloc2float(nt,nh);
  Wd=ealloc2float(nt,nh);
  model=ealloc2float(nt,nq);
  vgrid=ealloc2float(nt,nq);
  h=erealloc1float(h,nh);
  t=ealloc1float(nt);

  // for (ih=0;ih<nh;ih++) fprintf(stderr,"h[%d]=%f\n",ih,h[ih]);

  // Loop over traces 
  iq=0;
  do {
    memcpy((void *) model[iq],(const void *) tr.data,nt*sizeof(float));
    if (iq > nq) err("Number of traces > %d. Set correctly nq keyword. \n",nq); 
    //fprintf(stderr,"tr.tracl[%d]=%d\n",iq,tr.tracl);
    iq++;
  } while (fgettr(mp,&tr));
  nq=iq;

  for (it=0;it<nt;it++) t[it]=0+it*dt;

  for (iq=0;iq<nq;iq++){
    efread(vgrid[iq],sizeof(float),nt,vp);
    //for (it=0;it<nt;it++) fprintf(stderr,"vgrid[%d][%d]=%e\n",iq,it,vgrid[iq][it]);
  }
  // read data preconditioner

    
  //radonhyp(model[0],t,h,q,data[0],vgrid,0,nt,nh,nq); 
  radonhyp_sinc(model[0],t,h,q,data[0],vgrid,0,nt,nh,nq); 

  if (0) // Wd has not been defined yet. 
    for (ih=0;ih<nh;ih++) 
      for (it=0;it<nt;it++) 
	data[ih][it]*=Wd[ih][it];

  if (nw){
    /*
    typewav=1;   Read a wavelet generated by Matlab
    typewav=2;   Generate a Ricker with SU
    typewav=3;   Design a simple wavelet by hand
    */
    dtemp=ealloc1float(nt+nw);
    if ( typewav==1 || typewav == 2 ) nw=200;
    wavelet=ealloc1float(nw);

    nw=get_wavelet(wavelet,"BP_wavelet",nw,typewav,dt,fpeak);

    wavelet=erealloc1float(wavelet,nw);

    for (ih=0;ih<nh;ih++){
      contruc_2(0,0,nw,wavelet,nt,data[ih],dtemp);
      memcpy((void *) data[ih],(const void *) dtemp,nt*sizeof(float));
    }

    free1float(wavelet);
    free1float(dtemp);
  }

  if (smooth) smoothing(data[0],nt,nh,nl,nr,flag);

  if (!fgettr(dp,&tr)) err("datafile: can't read first trace");
  if (nh==tr.ntr){
    memcpy((void *) tr.data,(const void *) data[0],nt*sizeof(float));
    puttr(&tr);
    for (ih=1;ih<nh;ih++){ 
      fgettr(dp,&tr);
      memcpy((void *) tr.data,(const void *) data[ih],nt*sizeof(float));
      puttr(&tr);
    }
  }
  else{
    for (ih=0;ih<nh;ih++){ 
      memcpy((void *) tr.data,(const void *) data[ih],nt*sizeof(float));
      tr.offset=(int) h[ih];
      tr.ntr=nh;
      tr.tracl=ih;
      puttr(&tr);
    }
  }

  free1float(t);
  free1float(h);
  free1float(q);
  free2float(Wd);
  free2float(vgrid);
  free2float(model);
  free2float(data);
  efclose(mp);
  efclose(dp);
  efclose(vp);
  efclose(hp);
  finish=time(0);
  elapsed_time=difftime(finish,start);
  fprintf(stderr,"Total time required: %f \n", elapsed_time);

  return EXIT_SUCCESS;
}


void radonhyp(float *m,float *t, float *h, float *q, float *d, float **vel,int adj,int nt, int nh, int nq)
{
  register int it;
  int ih,iq;
  float ftime;
  float time,hxh,pxhxh;
  int iqxnt,ihxnt;
  int itime;
  int nx=nt*nq;
  int ny=nt*nh;
  float dt=t[1]-t[0];
  fprintf(stderr,"Crude approach nh=%d, nt=%d, nq=%d\n",nh,nt,nq);

  if (adj) memset((void *) m,(int)'\0',nx*FSIZE);  
  //for (it=0;it<nx;it++) m[it]=0;
  else  memset((void *) d,(int)'\0',ny*FSIZE);  
  //for (it=0;it<ny;it++) d[it]=0;

  for (it=0;it<nt;it++){
    for (ih=0;ih<nh;ih++){
      hxh=h[ih]*h[ih];
      ihxnt=ih*nt;
      for (iq=0;iq<nq;iq++){    
	pxhxh=hxh*vel[iq][it];
	iqxnt=iq*nt;
        time=sqrt(t[it]*t[it]+pxhxh);
	ftime=time/dt;
	itime=(int) floor(ftime+0.5);
	if (itime<nt){
	  if (adj) m[iqxnt+it]+=d[ihxnt+itime];
          else d[ihxnt+itime]+=m[iqxnt+it];
	}
      }            
    }
  }
  return;
}


void radonhyp_sinc(float *m,float *t, float *h, float *q, float *d, float **vel,int adj,int nt, int nh, int nq)
{
  register  int it;
  int ih,iq;
  float *ttn,*dint,*tnt,hxh,pxhxh;
  int iqxnt,ihxnt;
  int nx=nt*nq;
  int ny=nt*nh;
  float dt=t[1]-t[0];
  float dt2=dt*dt;

  if ((ttn=alloc1float(nt))==NULL)
    err("cannot allocate memory for ttn \n");
  if ((tnt=alloc1float(nt))==NULL)
    err("cannot allocate memory for tnt \n");
  if ((dint=alloc1float(nt))==NULL)
    err("cannot allocate memory for dint \n");
  fprintf(stderr,"Sinc interpolation +++++++++\n");

  if (adj)  for (it=0;it<nx;it++) m[it]=0;
  else for (it=0;it<ny;it++) d[it]=0;   

  for (ih=0;ih<nh;ih++){
    hxh=h[ih]*h[ih];
    ihxnt=ih*nt;
    for (iq=0;iq<nq;iq++){    
      iqxnt=iq*nt;
      for (it=0;it<nt;it++){
	pxhxh=hxh*vel[iq][it];
	ttn[it]=sqrt(t[it]*t[it]/dt2+pxhxh/dt2);
      }	
      if (adj) ints8r(nt,1.0,0,&d[ihxnt],0.0,0.0,nt,ttn,dint);
      else{
	yxtoxy(nt,1.0,0.0,ttn,nt,1.0,0.0,-nt,nt,tnt);
	ints8r(nt,1.0,0,&m[iqxnt],0.0,0.0,nt,tnt,dint);
      }
      if (adj) for (it=0;it<nt;it++) m[iqxnt+it]+=dint[it];
      else  for (it=0;it<nt;it++) d[ihxnt+it]+=dint[it];
    }            
  }
  free1float(dint);
  free1float(ttn);
  free1float(tnt);  
  return;
}








