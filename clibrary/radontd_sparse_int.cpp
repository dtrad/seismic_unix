#include "su.h"
#include "clibrarytd.h"
#include "radontd_sparse.h"


void radontd_sparse(float *t, float *q, float *h, float **m,float **d, int nt, int nh, int nq, float dt, float *vel, float dperv, float pervmin, float t0,  inv_par inv, int centralq, int filtout, int nw, float fpeak, int typewav)

  /*
    RADONTD_SPARSE
    RADON TRANSFORM IN TIME DOMAIN WITH SINC INTERPOLATION
    This function is called by suradontd0.cpp
    The Makefilesuradontd0_sinc produces the exec file 
    suradontd0_sinc

    This file has the problem that it does not pass the dot product test. 
    It is probably no possible to define the adjoint because the operator depends 
    on the data. Another problem is that the times resulting from the hyperbolic equation
    requires to be sort. This is not possible oin general when the velocity ocntrast
    is large. No solution so far fopr this problem.
    
    To keep all the variants of radontd_sparse called by the same file we include
    the extra parameter int typewav, without meaning in this file.  
    Daniel Trad - UBC October 2000
    E-mail: dtrad@geop.ubc.ca
  */
{
  register int it;
  int  j, ih, iq, iw;
  float **Wm; // Model weights
  float **Wd;// Data weights
  unsigned int **index; // sparse matrix L
  int nsparse;
  int ntaper=5; // Number of lateral traces to taper 
  int it0=(int) (t0/dt+0.5);
  float test;
  float *wavelet;
  char buf[80];
  int testadj=1;
  float dotwav;
  //////////////////////////////////////////////////////////////////////////
  // Define pointers to functions to be used with operators
  void (*radon3sw) (float *m, float *d, unsigned int **index, int adj, int nt, 
		   int nh, int nq, int nsparse, float *wavelet, int nw);

  void (*radon3s) (float *m, float *d, unsigned int **index, int adj, int nt, 
		   int nh, int nq, int nsparse);

  void (*convop)  (int, int, int, float *,int, float *,float *);

  // The actual functions to be used are
  radon3sw=radonhyp;
  radon3s=radonhyp;
  convop=contruc_2;
  //convop=contran;

  // Generate a wavelet for the forward and adjoint operator and plot it


  if (nw){
    /*
    typewav=1;   Read a wavelet generated by Matlab
    typewav=2;   Generate a Ricker with SU
    typewav=3;   Design a simple wavelet by hand
    */
    if ( typewav==1 || typewav == 2 ) nw=200;
    wavelet=ealloc1float(nw);
    TRACE;
    nw=get_wavelet(wavelet,"BP_wavelet",nw,typewav,dt,fpeak);
    TRACE;
    wavelet=erealloc1float(wavelet,nw);
    fprintf(stderr,"Test dot product for contran\n");
    test=testadjop_conv(convop,nw,wavelet,nt,nt+nw-1);
  }    

  Wm=ealloc2float(nt,nq);
  Wd=ealloc2float(nt,nh);

  ///////////////////////////////////////////////////////////////////
  
  //if (inv.taperflag==1) taper(d,nt,nh,ntaper,0);
    
  //   Velocity axis //////////////////////////////////////////////////
  float **vgrid;
  if ((vgrid=alloc2float(nt,nq))==NULL) err("Cannot allocate vgrid");
  fprintf(stderr,"nq=%d,nt=%d,pervmin=%f,dperv=%f,centralq=%d\n",
	  nq,nt,pervmin,dperv,centralq);
  irreg_slowness_axis(nq,nt,pervmin,dperv,t,vel,q,vgrid,centralq);
  save2dfile(vgrid,nq,nt,dt,"vgrid");
    //  else irreg_vel2inv_axis(nq,nt,pervmin,dperv,t,vel,q,vgrid);
  for (iq=0;iq<nq;iq++) memset((void *)m[iq],(int)'\0',nt*FSIZE);
  
  nsparse=(nt-it0)*nq*nh; 
  fprintf(stderr,"nsparse=%d\n",nsparse);
  // allocate the big monster
  size_t size=sizeof(unsigned int);
  if ((index=(unsigned int **) alloc2(nsparse,2,size))==NULL) 
    err("Cannot allocate index\n");

  // Assign the elements of index

  build_index_slowness(t,h,q,vgrid,nt,nh,nq,index,it0);


  // Test the adjoint
  if (testadj && nw ) test=testadjop(radon3sw,index,nt,nh,nq,nsparse,wavelet,nw);
  else if (testadj) test=testadjop(radon3s,index,nt,nh,nq,nsparse);
  if (0){
  if (((int) test) !=1 ){
    fprintf(stderr,"test=%f\n",test);
    for (iw=0;iw<nw;iw++) wavelet[iw]/=test;
    if (testadj && nw ) test=testadjop(radon3sw,index,nt,nh,nq,nsparse,wavelet,nw);
  }
  }
  // Adjoint   
  if (nw) radonhyp(m[0],d[0],index,1,nt,nh,nq,nsparse,wavelet,nw);
  else radonhyp(m[0],d[0],index,1,nt,nh,nq,nsparse);
  if (1){ 
    save_gather(m,nq,nt,dt,"model");
    system("suxwigb < model  title=\"plotgather\" &");
  }
  
  // This is a filter for outliers or dominant bad data
  if (filtout){
    //radonhyp(m[0],Wd[0],index,0,nt,nh,nq,nsparse);
    float qup=quest(0.999,nh*nt,d[0]);
    float qmean=quest(0.50,nh*nt,d[0]);
    for (ih=0;ih<nh;ih++) 
      for (it=0;it<nt;it++) 
	if (fabs(d[ih][it])>qup) Wd[ih][it]=qmean/qup;
	else Wd[ih][it]=1.0;
  }
  else for (ih=0;ih<nh;ih++) for (it=0;it<nt;it++) Wd[ih][it]=1.0;

  fprintf(stderr,"inv.norm=%d,inv.eps1=%f,inv.eps2=%f,inv.itercg=%d,inv.iter_end=%d,inv.eps=%f,inv.restart=%d,inv.step=%f\n",inv.norm,inv.eps1,inv.eps2,inv.itercg,inv.iter_end,inv.eps,inv.restart,inv.step);    

  for (j=1;j<=inv.iter_end;j++){
    // norm==1 ==> L1 , ==0  Cauchy else l2
    modelweight(m[0],nq*nt,inv.norm,inv.eps1,Wm[0]);
    if (nw && j==inv.iter_end){ 
      fprintf(stderr,"iteration with wavelet convolution\n");
      wpcgnr(radon3sw,nt,nh,nq,nsparse,m[0],d[0],Wd[0],Wm[0],index,inv,wavelet,nw);
    }
    else wpcgnr(radon3s,nt,nh,nq,nsparse,m[0],d[0],Wd[0],Wm[0],index,inv);
  }

  if (nw) radonhyp(m[0],d[0],index,0,nt,nh,nq,nsparse,wavelet,nw);
  else radonhyp(m[0],d[0],index,0,nt,nh,nq,nsparse);

  // Let us kill the monster
  free2((void **) index);
  
  free2float(vgrid);  
  free2float(Wm);
  free2float(Wd);  
  if (nw) free1float(wavelet);

  return;
  
}

void build_index_slowness(float *t, float *h, float *q, float **vel, int nt, int nh, int nq,unsigned int **index, int it0)
{
  register int it;
  int ih,iq;
  float time,hxh,pxhxh;
  int iqxnt,ihxnt;
  int itime;
  int nsparse=(nt-it0)*nq*nh;
  float dt=t[1]-t[0];
  int it00;

  for (it=0;it<nsparse;it++) index[0][it]=index[1][it]=0;
  
  for (ih=0;ih<nh;ih++){
    hxh=h[ih]*h[ih];
    ihxnt=ih*nt;
    for (iq=0;iq<nq;iq++){    
      iqxnt=iq*nt;
      for (it=it0;it<nt;it++){
	if (vel[iq][it]>0){
	  it00=it-it0;
	  pxhxh=hxh*vel[iq][it];
	  // In this function we multiply by 10 before truncation to save
	  // the first decimal digit. Later the times are multiply by 0.1
	  time=10*sqrt(t[it]*t[it]+pxhxh);
	  itime=(int) (time/dt+0.5);
	  if (itime<(nt*10)){
	    index[0][ih*nq*(nt-it0)+iq*(nt-it0)+it00]=(10*ihxnt)+itime;
	    index[1][ih*nq*(nt-it0)+iq*(nt-it0)+it00]=iqxnt+it;
	  }
	  else{
	    index[0][ih*nq*(nt-it0)+iq*(nt-it0)+it00]=0;
	    index[1][ih*nq*(nt-it0)+iq*(nt-it0)+it00]=0;
	  }
	}
      }            
    }
  }
  return;
}

void radonhyp(float *m, float *d, unsigned int **index, int adj, int nt, int nh, int nq, int nsparse)
{
  // This function is similar to radonhyp but it performs linear interpolation
  // The first column of index has been multiplied by 10 to keep the first decimal
  // place after truncation. 
  /// D. Trad - October 2000
  int j;
  int ny=nh*nt;
  int nx=nq*nt;
  int id1;
  int id2;
  int im1;
  float a;

  d[0]=0;
  m[0]=0;

  
  if (!adj){
    memset((void *) d,(int)'\0',ny*FSIZE);
    for (j=0;j<nsparse;j++){
      id1=(int) ( 0.1 * index[0][j] );
      im1=index[1][j];
      if (id1 && im1 ){
	id2=id1+1;
	a=( 0.1 * index[0][j])-id1;
	d[id1]+=(1-a)*m[im1];
	d[id2]+=a*m[im1];
      }
    }
  }
  else{
    memset((void *) m,(int)'\0',nx*FSIZE);
    for (j=0;j<nsparse;j++){
      id1=(int) ( 0.1 *index[0][j] );
      im1=index[1][j];
      if (id1 && im1 ){
	id2=id1+1;
	a=( 0.1 * index[0][j]-id1) ;
	m[im1]+=(1-a)*d[id1]+a*d[id2];
      }
    }
  }
  /* 
    A problem appears if some of the values of index are never computed
    because the zero index of d and m are mapped each other for index=0
    I make these two elements equal to zero just to prevent this problem, 
    It does not affect the data or model significantly.  
  */ 
			      
  d[0]=0;
  m[0]=0;

  return;
}



void radonhyp(float *m, float *d, unsigned int **index, int adj, int nt, int nh, int nq, int nsparse, float *wavelet, int nw)
{
  int it,j,ih;
  int ny=nh*nt;
  int nx=nq*nt;
  int lag=(nw+1)/2;
  float *dtemp;
  float *dtemp2;
  int id1;
  int id2;
  int im1;
  float a;

  //fprintf(stderr,"nw=%d,nt=%d,nh=%d,nq=%d\n",nw,nt,nh,nq);
  d[0]=0;
  m[0]=0;
  
  dtemp2=ealloc1float(ny);
  dtemp=ealloc1float(nt+nw);
  memset((void *) dtemp,(int)'\0',(nt+nw)*FSIZE); 
  memset((void *) dtemp2,(int)'\0',ny*FSIZE); 

  //for (j=0;j<nw;j++) fprintf(stderr,"nw=%d, wavelet[%d]=%f\n",nw,j,wavelet[j]);
  
  if (!adj){
    memset((void *) d,(int)'\0',ny*FSIZE);
    for (j=0;j<nsparse;j++){
      id1=(int) ( 0.1 * index[0][j] );
      im1=index[1][j];
      if (id1 && im1 ){
	id2=id1+1;
	a=( 0.1 * index[0][j])-id1;
	d[id1]+=(1-a)*m[im1];
	d[id2]+=a*m[im1];
      }
    }
    d[0]=0;
    for (ih=0;ih<nh;ih++){
      memset((void *) dtemp,(int)'\0',(nt+nw)*FSIZE); 
      contruc_2(0,0,nw,wavelet,nt,&d[ih*nt],dtemp);
      memcpy((void *) &d[ih*nt],(const void *) dtemp,nt*sizeof(float));
    }
  }
  if (adj){
    for (ih=0;ih<nh;ih++){
      memset((void *) dtemp,(int)'\0',(nt+nw)*FSIZE); 
      contruc_2(1,0,nw,wavelet,nt,dtemp,&d[ih*nt]);
      memcpy((void *) &dtemp2[ih*nt],(const void *) dtemp,nt*sizeof(float));
    }
    memset((void *) m,(int)'\0',nx*FSIZE);
    for (j=0;j<nsparse;j++){
      id1=(int) ( 0.1 *index[0][j] );
      im1=index[1][j];
      if (id1 && im1 ){
	id2=id1+1;
	a=( 0.1 * index[0][j]-id1) ;
	m[im1]+=(1-a)*dtemp2[id1]+a*dtemp2[id2];
      }
    }
    m[0]=0;
  }  
  
  /* 
     A problem appears if some of the values of index are never computed
     because the zero index of d and m are mapped each other for index=0
     I make these two elements equal to zero just to prevent this problem, 
     It does not affect the data or model significantly.  
  */
  d[0]=0;
  m[0]=0;
  
  free1float(dtemp2);
  free1float(dtemp);
  
  return;
}



float testadjop(void (*oper) (float *,float *,unsigned int **,int ,int ,int, int, int, 
			      float *wavelet, int nw),unsigned int **index,int nt, int nh, 
		int nq, int nsparse, float *wavelet, int nw)
{
  float *dr1;
  float *mr1;
  float *dr2;
  float *mr2;
  float dp1;
  float dp2;
  int it;
  int iq;
  int ih;
  float test;
  int ny=nt*nh;
  int nx=nt*nq;
  //////////////  


  if ((dr1=alloc1float(ny))==NULL)
    fprintf(stderr,"***Sorry, space for vrand1 could not be allocated\n");
  if ((mr1=alloc1float(nx))==NULL)
    fprintf(stderr,"***Sorry, space for vrand2 could not be allocated\n");
  if ((dr2=alloc1float(ny))==NULL)
    fprintf(stderr,"***Sorry, space for vrand1 could not be allocated\n");
  if ((mr2=alloc1float(nx))==NULL)
    fprintf(stderr,"***Sorry, space for vrand2 could not be allocated\n");

 
  for (it=0;it<nt;it++) for (ih=0;ih<nh;ih++) dr1[ih*nt+it]=frannor();
  for (it=0;it<nt;it++) for (iq=0;iq<nq;iq++) mr1[iq*nt+it]=frannor();

  oper(mr2,dr1,index,1,nt,nh,nq,nsparse,wavelet,nw);
  oper(mr1,dr2,index,0,nt,nh,nq,nsparse,wavelet,nw);

  dp1=dot(ny,dr1,dr2);
  dp2=dot(nx,mr1,mr2);

  if (dp2!=0) test=dp1/dp2;
  else test=0;

  fprintf(stderr,"Test adjoint = %f dp1=%f, dp2=%f \n",test,dp1,dp2);
  return(test);
  
  free1float(mr2);
  free1float(dr2);
  free1float(mr1);
  free1float(dr1);

}

float testadjop(void (*oper) (float *,float *,unsigned int **,int ,int ,int, int, int),unsigned int **index,int nt, int nh, int nq, int nsparse)
{
  float *dr1;
  float *mr1;
  float *dr2;
  float *mr2;
  float dp1;
  float dp2;
  int it;
  int iq;
  int ih;
  float test;
  int ny=nt*nh;
  int nx=nt*nq;
  //////////////  



  if ((dr1=alloc1float(ny))==NULL)
    fprintf(stderr,"***Sorry, space for vrand1 could not be allocated\n");
  if ((mr1=alloc1float(nx))==NULL)
    fprintf(stderr,"***Sorry, space for vrand2 could not be allocated\n");
  if ((dr2=alloc1float(ny))==NULL)
    fprintf(stderr,"***Sorry, space for vrand1 could not be allocated\n");
  if ((mr2=alloc1float(nx))==NULL)
    fprintf(stderr,"***Sorry, space for vrand2 could not be allocated\n");

 
  for (it=0;it<nt;it++) for (ih=0;ih<nh;ih++) dr1[ih*nt+it]=frannor();
  for (it=0;it<nt;it++) for (iq=0;iq<nq;iq++) mr1[iq*nt+it]=frannor();

  oper(mr2,dr1,index,1,nt,nh,nq,nsparse);
  oper(mr1,dr2,index,0,nt,nh,nq,nsparse);

  dp1=dot(ny,dr1,dr2);
  dp2=dot(nx,mr1,mr2);

  if (dp2!=0) test=dp1/dp2;
  else test=0;

  fprintf(stderr,"Test adjoint = %f \n",test);
  return(test);
  
  free1float(mr2);
  free1float(dr2);
  free1float(mr1);
  free1float(dr1);

}


void irreg_slowness_axis(int nq, int nt, float pervmin, float dperv, float *t, float *vel,float *q, float **vgrid, int centralq)
{
  /*   Velocity Grid 
   Irregular velocity grid
   Define irregular spacing along the horizontal
   Here q  is perturbartion around the central velocity law
   dperq is a parameter used to generate the increasing space
   perqmin defines the minimum distance to the perturbation */
     
  float *perv;
  int it;
  int iq;
  int nqh=centralq;
  float vaux;
  fprintf(stderr,"pervmin=%f,dperv=%f\n",pervmin,dperv);
  if ((perv=alloc1float(nq+1))==NULL) err(" Cannot allocate perv");
  perv[nqh]=0;
  for (iq=nqh;iq<nq;iq++) perv[iq+1]=perv[iq]*(1+dperv)+pervmin;
  for (iq=nqh-1;iq>=0;iq--) perv[iq]=perv[iq+1]*(1+dperv)-pervmin;
  for (iq=0;iq<nq;iq++){
    //fprintf(stderr,"perv[%d]=%f\n",iq,perv[iq]);
    for (it=0;it<nt;it++){
      vaux=perv[iq];
      vgrid[iq][it]=1./(vel[it]*vel[it])+vaux;
      //if (vgrid[iq][it]<0) vgrid[iq][it]=0;//vgrid[iq][MAX(it-1,0)];
    }
    //    q[iq]=perv[iq];
    q[iq]=(vgrid[iq][0]);
    //fprintf(stderr,"vtop[%d]=%6.0f<======>,vbot[%d]=%6.0f\n",iq,sqrt(1./q[iq]),iq,sqrt(1./vgrid[iq][nt-1]));
  }
  //  for(iq=0;iq<nq;iq++) fprintf(stderr,"q[%d]=%f\n",iq,q[iq]);
  free1float(perv); 
  return;
}

void modelweight(float *m, int nx, int norm, float eps1, float *Wm)
  /*
  The right Wm from Cauchy is 
  Wm[i]=sqrt(eps1*eps1+m[i]*m[i]/(maxm*maxm));
  But if M^-1 ATA x = M^-1 AT b is solved instead
  of the satndard form M=WmT *Wm 
  Actually it works even better with (I don't know why)
  Wm[i]=Wm[i]*Wm[i];
  if (Wm[i]>2) Wm[i]=2; 
  */

{ 
      int i;
      float maxm;
      maxm=fabs(m[isamax(nx,m,1)]);

      if (norm==1) for (i=0;i<nx;i++) Wm[i]=fabs(m[i])+eps1;
      else if(norm==0){
	if (maxm>1e-4) 
	  for (i=0;i<nx;i++) Wm[i]=(eps1*eps1+m[i]*m[i]/(maxm*maxm));
 	else for (i=0;i<nx;i++) Wm[i]=1e-3;
      }
      else for (i=0;i<nx;i++) Wm[i]=1.;     
      fprintf(stderr,"+++++++++++norm=%d,maxm=%f,eps1=%f,Wmmax=%f\n",norm,maxm,
	      eps1,Wm[isamax(nx,Wm,1)]);

      return;
}









































