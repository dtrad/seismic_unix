/* Copyright (c) University of British Columbia, 1999.*/
/* All rights reserved.                       */

/* suinterpfk4 :  $Date: November 2001- Last version January 2000  */

#include "interpfk1.h"
#include "segy.h"
#include "header.h"
#include <time.h>

/*********************** self documentation **********************/
char *sdoc[] = {
  " 	   								",
  " SUINTERPFK1  Interpolation with LS square time migration            ", 
  "	         by using Stolt fk operator and several velocities      ",
  " 	   								",
  " suinterpfk4  < stdin > stdout [optional parameters]          	",
  " 									",
  " Given a data set with gaps or poor sampling this program adds       ",
  " new traces into the gaps or between traces and uses a least         ",
  " squares migration algorithm (with Stolt operator) to move the       ",
  " energy to these new traces, performing interpolation.               ",
  " If the original gather is irregularly sampled then a discrete       ",
  " Fourier transform is used in the offset direction                   ",
  " (dft=1, see below). This is slow, so in general a FFT along         ",
  " offset is prefered.                                                 ",
  " A sparseness constraint can be enforced (in the time domain)        ",
  " by using more than one iteration (iter_end > 1).                    ",
  " This improves interpolation. Itercg always is set to > 1,  but      ",
  " in general 3-5 iterations in the CG algorithm are enough.           ", 
  "                                                                     ",
  " Required parameters:		[None]		       		",
  "                                                                	",
  " Standard input : data file  (offset time domain)          		",
  " Standard output : Interpolated data file                            ",
  " modelfile= 	    Migrated gather        				",
  "                                                                     ",
  " Optional parameters:		       				",
  " option=1        1 sinc interpolation with (interpfact-1)            ",
  "                   non-zero traces                                   ",
  "                 2 interpolate first with (interpfact-1)             ", 
  "                   zero traces and then fill them with LS migration  ",
  "                 3 interpolate gaps first with zero traces           ",
  "                   as specified by offsetfile                        ",
  "                   and then fill them with LS migration              ",
  "                 other.. do not interpolate                          ",
  " nv=5            number of velocity laws in the model space          ",
  " dv=200          increment between velocity laws                     ",
  " modelfile=      migrated domain (sufile)                            ",
  " offsetfile=     ascii file with new offset (1 columm)               ",
  " interpfact=2    Factor for increasing sampling      		",
  " dft=0           0 2D FFT; 1 1D FFT + 1D DFT                       	",
  " vmig=2000       Velocity trend                                      ",
  " tmig            Time for velocity trend                             ",
  " eps1=0.8        Quantil to use in the numerator hyperparameter      ",
  "                 for Wm                                              ",
  " eps1=0.8        Quantil to use in the denomirator hyperparameter    ",
  "                 for Wm                                              ",
  " itercg=3        Internal iterations for CG                          ",
  " iter_end=2      External iterations for CG                          ",
  " step=1          step scale for CG (use 0.8-0.9 for more stable      ",
  " norm=0          0 Cauchy 1 L1                                       ",
  " testadj=0       Calculate adjoint test (Claerbout,1992)             ",
  " verbose=1       =1  verbose output                                  ",
  " plot=0          =1  additional plots (debug and testing)            ",
  " plot2=0         =1  additional plots for testing migration operator ",
  "                 without LS                                          ",
  " Experimental convolution in the operator                            ",
  " (does not work very well, in general do not convolve by setting nw=0",
  " typewav=1       1 Read a wavelet generated by Matlab                ",
  "                          (stored in an ascii file)                  ",  
  "                 2 Generate a Ricker with SU                         ",
  "                 3 Design a simple wavelet                           ",
  " fpeak=25        peak frequency for the Ricker wavelet               ",     
  " nw=0            lenght of a wavelet   =0 No convolution applied     ", 
  "            	                                        		",
  "		                                        		",
  "		                                        		",
  "		                                        		",
  " Example1: Interpolate by a factor of 2                              ",
  "		                                        		",
  " suinterpfk1 < filein  vmig=3000,4000 tmig=0,2 option=2  dft=0       ",
  " itercg=5 iter_end=3 step=0.98 eps1=8e-1 eps2=8e-1                   ",
  " modelfile=migrated_file  interpfact=2  > fileout                    ",
  "                                                                     ",
  " Example2: Interpolate gaps                                          ",
  "		                                        		",
  " suinterpfk1 < filein  vmig=3000,4000 tmig=0,2 option=2  dft=1       ",
  " itercg=5 iter_end=3 step=0.98 eps1=8e-1 eps2=8e-1                   ",
  " modelfile=migrated_file offsetfile=ascii_file  > fileout            ",
  NULL};
/* Credits:
 *	Daniel Trad.
 * Trace header fields accessed: ns, dt, offset
 * Last changes: January 18: 2002 
 */
/**************** end self doc ***********************************/



int main(int argc, char **argv)
{
  int verbose;
  segy tr; 
  inv_par inv;
  cwp_String modelfile=""; /* output sufile for the model */ 	
  FILE *modelfilep;
  //  FILE *offsetfile; 
  time_t start,finish;
  double elapsed_time;
  int it,ih, ik;
  float vel; // after time stretching vel represents constant velocity
  float *velarray; 
  float t0=0;
  float **datain=0;
  float **dataout=0;
  float **datains=0;
  float **dataouts=0;
  float **dataout0;
  float *t, *h, *h2, *k;
  complex **F=0;
  complex **F2=0;
  int nt, nh, nh2, nk; 
  int method;
  int plot; 
  int plot2;
  float dt,dk,dh2;
  float kmin;
  int testadj;
  int dft;
  float fmax;
  float ascale;
  int option;

  // Velocity law and stretching
  float *tmig;
  float *vmig;
  int ntmig;
  int nvmig;
  int itmig;
  float smig;
  float vscale,vstolt,vmin,vmax,ft,du,*v,*ut,*tu;
  int nu;
  
  // interpolation by zero padding or zero traces */
  float **dataout1;
  float interpfact;
  float dh=0;

  // data weights
  float **Wd=0;
  float **Wds=0;
  
  ////////////////
    
  cwp_String offsetfile=NULL; /*input ascii file for offset if interpolation is desired */
  //////////////////////////////////////////////
  fprintf(stderr,"*******SURADONHYPFK*********\n");
  // Initialize 
  initargs(argc, argv);
  requestdoc(1);

  start=time(0);    
  // Get parameters 
  if (!getparint("method", &method))  method = 0;
  if (!getparfloat("eps1", &inv.eps1))  inv.eps1 = 0.8;
  if (!getparfloat("eps2", &inv.eps2))  inv.eps2 = 0.8;
  if (!getparfloat("eps", &inv.eps))  inv.eps = 1e-7;
  if (!getparint("iter_end", &inv.iter_end))  inv.iter_end = 1;
  if (!getparfloat("step", &inv.step))  inv.step =1;
  if (!getparint("itercg", &inv.itercg))  inv.itercg = 3;
  if (!getparint("norm", &inv.norm))  inv.norm =0; 
  if (!getparstring("modelfile",&modelfile)) modelfile="model.su";    
  if (!getparint("verbose", &verbose))  verbose =1;
  if (!getparint("restart",&inv.restart)) inv.restart = 1;
  if (!getparint("plot",&plot)) plot = 0;
  if (!getparint("plot2",&plot2)) plot2 = 0;
  if (!getparint("testadj",&testadj)) testadj=0; 
  if (!getparint("dft",&dft)) dft=0; 
  if (!getparstring("offsetfile",&offsetfile)) offsetfile=NULL;
  if (!getparfloat("kmin",&kmin)) kmin=0;
  if (!getparfloat("interpfact",&interpfact)) interpfact=2;
  if (!getparint("option",&option)) option=2;
  if (!getparint("nv",&nv)) nv=5;
  if (!getparfloat("dv",&dv)) dv=200;
  if ((option==3)&&(offsetfile==0)) err("option==3 requires to input a new offset");

  // Velocity law
  if (!getparfloat("vscale",&vscale)) vscale = 1.0;
  if (!getparfloat("ascale",&ascale)) ascale = 1.0;
  ntmig=countparval("tmig");
  if (ntmig==0) ntmig=1;
  tmig=ealloc1float(ntmig);
  if (!getparfloat("tmig",tmig)) tmig[0]=0.0;

  nvmig=countparval("vmig");
  if (nvmig==0) nvmig=1;
  vmig=ealloc1float(nvmig);
  if (!getparfloat("vmig",vmig)) vmig[0]=2000.0;
  
  if (ntmig!=nvmig) err("number of tmig and vmig must be equal");
  for (itmig=1;itmig<ntmig;++itmig)
    if (tmig[itmig]<=tmig[itmig-1])
      err("tmig must increase monotonically");
  if (!getparfloat("smig",&smig)) smig=1.0;
  // Wavelet for the RT operator
  int nw;        // number of point for the wavelet
  float fpeak;   // peak frequency for the wavelet
  int typewav;   // type of wavelet
  float *wavelet=0;
  void (*convop)  (int, int, int, float *,int, float *,float *);

  if (!getparint("nw",&nw)) nw =0;
  if (!getparfloat("fpeak",&fpeak)) fpeak =25;
  if (!getparint("typewav",&typewav)) typewav = 1;




  convop=contruc_2;

  if (!gettr(&tr)) err("can't read first trace");
  if (!tr.dt) err("dt header field must be set");
  if (!tr.ns) err("ns header field must be set");
  if (!tr.ntr) err("ntr header field must be set");

  dt   = ((float) tr.dt)/1000000.0;
  nt = (int) tr.ns;
  nh= (int) tr.ntr;
  nh2=10*nh;
  ft = tr.delrt/1000.0;
  if (ft!=0.0) err("cannot handle non-zero time of first sample");

  /* for mute in the migrated space we need to set the geometry of the mask */
  int mute; 
  mutemask_par par;


  if (!getparint("mute",&mute)) mute = 0;
  if (!getparfloat("tmin_m",&par.tmin)) par.tmin = 0.; 
  if (!getparfloat("tmax_m",&par.tmax)) par.tmax = nt*dt;
  if (!getparint("ihmin_m",&par.ihmin)) par.ihmin = (int) (nh/2+2);
  if (!getparint("ihmax_m",&par.ihmax)) par.ihmin = (int) (nh);
  if (!getparfloat("slope_m",&par.slope)) par.slope = 3;     
  if (!getparfloat("thres_m",&par.threshold)) par.threshold = 0.2;     

  /**************************************************************************/

  if (!getparfloat("fmax",&fmax)) fmax = 0.5/dt;
  fmax = MIN(fmax,0.5/dt);
  
  /* Correct for a factor 2 the given velocities */
  for (itmig=0;itmig<ntmig;++itmig) vmig[itmig]*=2;

  /* make uniformly sampled rms velocity function of time */
  makev(ntmig,tmig,vmig,vscale,nt,dt,ft,&v,&vmin,&vmax);
  
  /* Stolt migration velocity is the minimum velocity */
  vel = vstolt = vmin;
  velarray[iv]=vel;
  for (iv=1;iv<nv;iv++) velarray[iv]=velarray[iv-1]+dv;

  /* make u(t) and t(u) for Stolt stretch */
  makeut(vstolt,fmax,v,nt,dt,&ut,&nu,&du,&tu);
  free1float(v);
  

  /*********************************************************************/
  /* Generate a wavelet for the forward and adjoint operator and plot it
    typewav=1==>   Read a wavelet generated by Matlab (stored in an ascii file)
    typewav=2==>   Generate a Ricker with SU
    typewav=3==>   Design a simple wavelet by hand
  */

  if (nw){
    //if ( typewav==1 || typewav == 2 ) nw=50;
    wavelet=ealloc1float(nw);
    nw=get_wavelet(wavelet,"BP_wavelet",nw,typewav,du,fpeak);
    wavelet=erealloc1float(wavelet,nw);
    fprintf(stderr,"Test dot product for contran\n");
    //test=testadjop_conv(convop,nw,wavelet,nu,nu+nw-1);
  }      
  /*********************************************************************/

  if (verbose){
    fprintf(stderr,"New time axis after stretching: nt=%d ,dt=%f \n",nu,du);  
    fprintf(stderr,"Option=%d is selected\n",option);  
    if (option==1) 
      fprintf(stderr,"Means sinc interpolation before migration \n");
    else if (option==2)  
      fprintf(stderr,"Means zero traces interpolation before migration \n");
    else if (option==3)  
      fprintf(stderr,"Means fill in gaps according to offsetfile \n");
    if ((option==1)||(option==2)) 
      fprintf(stderr,"%f traces will be inserted between original traces\n",(interpfact-1));
    if (dft) fprintf(stderr,"Usign DFT for the offset direction\n");
  }

  // Allocate memory for data and model

  datain=ealloc2float(nt,nh);
  h=ealloc1float(nh);
  t=ealloc1float(nt);
  velarray=ealloc1float(nv);

  memset( (void *) h, (int) '\0', nh * FSIZE);
  /* If offetfile name is given read it */
  h2=ealloc1float(nh2); // allocate more to play safe
  memset( (void *) h2, (int) '\0', nh2 * FSIZE);


  if (option==3) if (offsetfile) nh2=read_ascii_file(offsetfile,h2); 
  else nh2=nh;

  dataout0=ealloc2float(nt,nh);

  // Loop over traces 
  if (verbose) fprintf(stderr,"Original traces are:\n");
  ih=0;
  do {
    h[ih]=(float) tr.offset;
    memcpy((void *) datain[ih],(const void *) tr.data,nt*sizeof(float));
    ih++;
    if (ih > nh) err("Number of traces > %d\n",nh); 
    if (verbose) fprintf(stderr,"ih=%d\n",ih);   
  } while (gettr(&tr));
  erewind(stdin);
  nh=ih;

  /* Time axis */
  for (it=0;it<nt;it++) t[it]=t0+it*dt;  /* Not implemented for t0 != 0  */

  /***************************************************************** 
     From this point the program has to create two new data spaces
     first: original sampling in offset to new offset sampling (interpolation) 
     second: original time sampling to new time sampling (stretching)
  *******************************************************************/


  /* Create the interpolated data space */
  if ((option==1)||(option==2)){
    dataout1=ealloc2float(nt,200);
    Wd=ealloc2float(nt,nh*(int) interpfact);
  }
  else if (option==3){
    dataout1=ealloc2float(nt,nh2);
    Wd=ealloc2float(nt,nh2);
  }
  else{
    dataout1=ealloc2float(nt,nh);
    Wd=ealloc2float(nt,nh);
  } 

  /***** Initial offset interpolation *****/

  if (plot){ /* additional plots only for degugging  */  
    save_gather(datain,nh,h,nt,dt,"datain.su");
    system("suxwigb < datain.su perc=100 key=offset title=datain &");  
  }
  if (option==1)   /* initial interpolation by zero padding in f-k */
    nh2=fft2_zeropad(datain,dataout1,Wd,nt,nh,interpfact);
  else if (option==2)   /* initial interpolation by zero padding in t-x */
    nh2=add_zerotraces(datain,dataout1,Wd,nt,nh,interpfact);
  else if (option==3)   /* initial interpolation by filling gaps by zero padding in t-x */
    nh2=add_zerotraces(datain,dataout1,Wd,nt,nh,nh2,h,h2);
  else for (ih=0;ih<nh2;ih++) h2[ih]=h[ih]; /* for wrong option  */

  /************************************************/
  /* Create new offset axis */  
  if ((option==1)||(option==2)){ 
    dh=(h[nh-1]-h[0])/(nh-1);
    dh2=dh/interpfact;
    for (ih=0;ih<nh2;ih++) h2[ih]=h[0]+ih*dh2;
  }
  else if (option==3){
    dh=(h[nh-1]-h[0])/(nh-1);
    dh2=(h2[nh2-1]-h2[0])/(nh2-1);
  }
  else dh2=(h2[nh2-1]-h2[0])/(nh2-1);
  
  /* Replace original offset axis with the new one */
  h=realloc1float(h,nh2);
  for (ih=0;ih<nh2;ih++) h[ih]=h2[ih];
  nh=nh2;

  if (verbose) fprintf(stderr,"New offset axis has dh=%f, nh=%d\n",dh,nh);
  if (plot){
    save_gather(dataout1,nh2,h2,nt,dt,"dataout1.su");
    system("suxwigb < dataout1.su perc=100 key=offset title=dataout2 &");    
  }

  /************************************************/
  
  /* Replace  original data array with the new one*/
  free2float(datain);
  datain=ealloc2float(nt,nh2);
  for (ih=0;ih<nh2;ih++) for (it=0;it<nt;it++) datain[ih][it]=dataout1[ih][it]; 
  /* Temporal array dataout1 is no longer needed */
  free2float(dataout1);
 
  /**************** Time stretching  ******************/
  /*** The new data space has different nt (due to the time stretching) */
  if (verbose) fprintf(stderr,"Time stretching: old nt=%d, New nt=%d\n",nt,nu);

  datains=ealloc2float(nu,nh);
  dataouts=ealloc2float(nu,nh2);
  Wds=ealloc2float(nu,nh2);
  
  stretch(datain,datains,nt,nu,nh,t,tu,ut,dt,du,1);
  stretch(Wd,Wds,nt,nu,nh,t,tu,ut,dt,du,1);

  free2float(Wd);

  /* If the velocity is constant the time axis was not created before */
  if (nu==nt){
    tu=ealloc1float(nt);
    ut=ealloc1float(nt);
    for (it=0;it<nt;it++) tu[it]=ut[it]=t[it];
  }

  /******** Need wavenumber axis ********/
  kaxis(nh2,vel,du,nu,dh2,&nk,&dk,dft);
  k=ealloc1float(nk);
  for (ik=0;ik<nk;ik++) k[ik]=kmin+ik*dk;

  if (verbose) fprintf(stderr,"Wavenumber axis has nk=%d,dk=%f \n",nk,dk);
  /**************************************/
  
  /* 
     If discrete FT is desired (irregular offset axis) 
     then we need the operator F that performs d=Fm
  */
  if (dft){
    F=ealloc2complex(nk,nh);
    F2=ealloc2complex(nk,nh2);
    dft_matrix(F,h,k,nh,nk);
    dft_matrix(F2,h2,k,nh2,nk);
  }
  else{
    F=0;
    F2=0;
  }
  
  /************* Test for operators ***********/  
  if (plot2){ /* plot2 is normally o */
    save_gather(datain,nh,nt,0.004,"datain.su");
    system("suxwigb < datain.su perc=100 title=datain &");
  }	
  
  if (testadj) adjteststoltz(nu,nh,nh2,tu,h,h2,vel,F,F2,wavelet,nw);
  
  if (plot2){
    stoltzop2(datains,dataouts,nu,nh,nh2,tu,h,h2,vel,F,F2,wavelet,nw,1);
    save_gather(dataouts,nh2,nu,0.004,"dataout.su");
    system("suxwigb < dataout.su perc=100 title=dataout &");
  }	
   
  if (plot2){
    stoltzop2(datains,dataouts,nu,nh,nh2,tu,h,h2,vel,F,F2,wavelet,nw,0);
    save_gather(datains,nh,nu,0.004,"datain.su");
    system("suxwigb < datain.su perc=100 title=datain &");
  }	 

  if (plot2){
    save_gather(Wds,nh,nu,0.004,"Wd");
    system("suxwigb < Wd perc=100 title=Wd &");
  }
  /********************************************************/
  
  stoltz_wtcgls(datains,dataouts,Wds,h,nh,tu,nu,h2,nh2,vel,nv,dv,inv,F,F2,velarray,nv);
  
  // data weights no need any longer 
  free2float(Wds);
  
  /******* Migrated output **************/
  /* array for output and plots */
  dataout=ealloc2float(nt,nh2);    
  if (plot){
    stretch(dataout,dataouts,nt,nu,nh2,t,tu,ut,dt,du,-1);   
    save_gather(dataout,nh2,h,nt,0.004,"migrated.su");
    system("suxwigb < migrated.su perc=100 title=migrated &");
  }	 

  float **M=ealloc2float(MAX(nu,nt),nh);
  if (mute) mutemask(M,dataouts,nh,nu,du,par);

  if (0){
    save_gather(M,nh,h,nu,du,"mask.su");
    system("suxwigb < mask.su perc=100 title=mask &");
  }	

  if (mute) AtimesB(dataouts,M,nh,nu);
  free2float(M);

  /* Create output array for the migrated model */
  stretch(dataout,dataouts,nt,nu,nh2,t,tu,ut,dt,du,-1);

  modelfilep=efopen(modelfile,"w");

  erewind(stdin);

  for (ih=0;ih<nh2;ih++){ 
    fgettr(stdin,&tr);
    memcpy((void *) tr.data,(const void *) dataout[ih],nt*sizeof(float));
    /* If the scale is wrong (sometimes for dft=1) 
       apply a scale correction ascale*/
    for (it=0;it<nt;it++) tr.data[it]*=ascale;
    tr.offset=(int) h2[ih];
    tr.ntr=nh2;
    fputtr(modelfilep,&tr);
  }
  efclose(modelfilep);
  if (0){
  /** plot */ 
    char buf[80];
    sprintf(buf,"suxwigb < %s key=offset perc=99  title=%s & \n",modelfile,modelfile);
    system(buf);  
  }
  /******** End of migrated output **********/

  /******** Interpolated output *************/
  stoltzopinv2(dataouts,dataouts,nu,nh2,tu,h2,velarray,F2,wavelet,nw);
  
  if (0){
    save_gather(dataouts,nh2,nu,0.004,"demigrated.su");
    system("suxwigb < demigrated.su perc=100 title=demigrated &");
  }	

  stretch(dataout,dataouts,nt,nu,nh2,t,tu,ut,dt,du,-1);
  
  rewind(stdin);
  for (ih=0;ih<nh2;ih++){ 
    fgettr(stdin,&tr);
    memcpy((void *) tr.data,(const void *) dataout[ih],nt*sizeof(float));
    for (it=0;it<nt;it++) tr.data[it]*=ascale;
    tr.offset=(int) h2[ih];
    tr.ntr=nh2;
    fputtr(stdout,&tr);
  }
  /******** End of interpolated output **********/

  if (nw) free1float(wavelet); 

  if (dft){
    free2complex(F2);
    free2complex(F);
  }

  free1float(velarray);
  free1float(k);
  free1float(h2);
  free1float(t);
  free1float(h);
  free2float(datain);
  free2float(dataout);
  free2float(datains); 
  free2float(dataouts);
  free2float(dataout0);

  free1float(tmig);
  free1float(vmig);
  if (nt==nu){
    free1float(tu);
    free1float(ut);
  }

  finish=time(0);
  elapsed_time=difftime(finish,start);
  fprintf(stderr,"Total time required: %f \n", elapsed_time);

  return EXIT_SUCCESS;
}


















